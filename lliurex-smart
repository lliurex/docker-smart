#!/usr/bin/env python3

import os
import sys
import pwd
import grp
import subprocess
import logging as _logging
import logging.handlers as _handlers
import argparse
import time
import threading

IMAGE_NAME='lliurex/lliurex-smart:latest'
CONTAINER_NAME='smart'
MAIN_STORAGE_NAME="lliurex-smart-storage"
CONFIG_STORAGE_NAME="lliurex-smart-config"

DEBUG=0

################# END EDITABLE VARS ##################

def check_running_user():
	uid=os.geteuid()
	return (uid,pwd.getpwuid(uid).pw_name)

def check_running_group():
	gid=os.getegid()
	return (gid,grp.getgrgid(gid).gr_name)
	
current_uid,current_username = check_running_user()
LOGFORMAT='lliurex-smart as [{}({})] %(threadName)s %(levelname)s %(message)s'.format(current_username,current_uid)
if (DEBUG):
	_logging.basicConfig(level=_logging.DEBUG,format=LOGFORMAT)
else:
	#_logging.basicConfig(level=_logging.WARNING,format=LOGFORMAT)
	_logging.basicConfig(level=_logging.INFO,format=LOGFORMAT)
	
logging = _logging.getLogger()
_syslog_handler = _handlers.SysLogHandler(address='/dev/log')
_syslog_handler.setFormatter(_logging.Formatter(fmt=LOGFORMAT))
logging.addHandler(_syslog_handler)

MAX_THREAD_POOL=2
THREAD_POOL=[None]*MAX_THREAD_POOL
DOCKER_IS_INSTALLED=False

import json
def print_dic(obj):
	return json.dumps(obj,indent=4,sort_keys=True)

def execute(cmd,stdout=True,shell=False,stderr=subprocess.DEVNULL,universal_newlines=True):
	privileged_commands=['docker','modprobe']
	command=list()
	if isinstance(cmd,str):
		command.extend(cmd.split())
	elif isinstance(cmd,list):
		command.extend(cmd)
	else:
		raise ValueError("Wrong parameter passed to execute method, error is: '{}'".format(cmd))
	try:
		custom_env = os.environ.copy()
		custom_env["LANG"] = "en"
		custom_env["LANGUAGE"] = "en"
		custom_env["LC_ALL"] = "en.UTF-8"
		#logging.debug(print_dic(custom_env))
		for pc in privileged_commands:
			if pc in command[0]:
				command.insert(0,'pkexec')			
		logging.debug("Executing {}".format(command))
		output = subprocess.check_output(command,shell=shell,stderr=stderr,universal_newlines=universal_newlines,env=custom_env)
		retcode = 0
	except subprocess.CalledProcessError as e:
		retcode = getattr(e,"returncode",None)
		output = getattr(e,"output",None)
	except Exception as e:
		retcode = None
		output = None
		raise RuntimeError("Error calling subprocess, error is: '{}'".format(e))
	logging.debug("Command return: '{}' with output '{}'".format(retcode,output.strip()))
	if stdout:
		if output:
			output = output.strip()
		return (retcode, output)
	else:
		if retcode == 0:
			return True
		else:
			return False
def get_image_name():
	global IMAGE_NAME
	return IMAGE_NAME

def docker_installed():
	global DOCKER_IS_INSTALLED
	
	installed = False
	if not DOCKER_IS_INSTALLED:
		installed = execute('docker -v',False)
	else:
		installed = True

	if installed:
		DOCKER_IS_INSTALLED=True
	else:
		DOCKER_IS_INSTALLED=False
	
	#logging.debug("DOCKER_IS_INSTALLED={}".format(DOCKER_IS_INSTALLED))
	return DOCKER_IS_INSTALLED

def image_available():
	if not docker_installed():
		return False
	ret,out = execute('docker images -a -q {}'.format(get_image_name()))
	if out and len(out) == 12:
		logging.info('Image available')
		return True
	else:
		logging.info('Image not available')
		return False

def remove_image():
	if not docker_installed():
		raise OSError("Docker is not installed")
	ret = execute('docker rmi {}'.format(get_image_name()), False)
	if not image_available():
		return True
	else:
		raise SystemError("Error removing image")

def get_image():
	if not docker_installed():
		raise OSError("docker is not installed")
	return execute('docker pull {}'.format(get_image_name()), False)

def container_available():
	if not docker_installed():
		return False
	ret,out = execute('docker ps -a -q  -f=name=^/{}$ -f=ancestor={}'.format(get_container_name(),get_image_name()))
	if out and len(out) == 12:
		logging.info('Container is available')
		return True
	else:
		logging.info('Container is not available')
		return False

def get_container_name():
	global CONTAINER_NAME, current_username, current_uid
	return '{}-{}-{}'.format(CONTAINER_NAME,current_username,current_uid)
	
def get_container():
	global current_username
	
	if not docker_installed():
		raise OSError("Docker is not installed")
		
	cmdline=['docker run']
	cmdline.append('-i')
	cmdline.append('--privileged')
	cmdline.append('-v /tmp/.X11-unix:/tmp/.X11-unix')
	uid,uname=check_running_user()
	if storage_available():
		cmdline.append('-v {}:/home/{}'.format(get_storage_path(),uname))
	if config_storage_available():
		cmdline.append('-v {}:/root/.config'.format(get_config_storage_path(),uname))
	cmdline.append('-e DISPLAY=:0')
	gid,gname=check_running_group()
	cmdline.append('-e USER={}'.format(uname))
	cmdline.append('-e UID={}'.format(uid))
	cmdline.append('-e GROUP={}'.format(gname))
	cmdline.append('-e GID={}'.format(gid))
	cmdline.append('--name {}'.format(get_container_name()))
	
	cmdline = ' '.join(cmdline)
	cmdline += ' {}'.format(IMAGE_NAME)
	logging.info('Creating new container from {}'.format(get_image_name()))
	ret = execute(cmdline,False)
	if ret != 0:
		return False
	else:
		return True

def run_container():
	if not docker_installed():
		raise OSError("Docker is not installed")
	logging.info('Starting container {}'.format(get_container_name()))
	ret = execute('docker start {}'.format(get_container_name()))
	if ret != 0:
		return False
	else:
		return True
	
def container_running():
	if not docker_installed():
		raise OSError("Docker is not installed")
	if not container_available():
		return False
	go_format_status='{{.Status}}'
	ret, out = execute('docker ps -a -f=name=^/{}$ --format {}'.format(get_container_name(),go_format_status))
	wrong_status = ['dead','removing','exited']
	if not out:
		return False
	else:
		status = out.split()[0] or None
		if not status:
			raise SystemError("Error checking container_running")
		status = status.lower()
		if status in wrong_status:
			return False
		else:
			return True
	
def remove_container():
	if not docker_installed():
		raise OSError("Docker is not installed")
	logging.debug("Trying to remove container")
	if container_available():
		if container_running():
			stop_container()
		logging.info('Removing container')
		ret, out = execute('docker rm {}'.format(get_container_name()))
		if ret == 0:
			return True
		else:
			return False
	return True

def stop_container():
	if not docker_installed():
		raise OSError("Docker is not installed")
	if container_running():
		ret, out = execute('docker stop {}'.format(get_container_name()))
		if ret == 0:
			return True
		else:
			return False
	else:
		return True

def get_logs():
	if not docker_installed():
		raise OSError("Docker is not installed")
	logging.debug("Getting container logs")
	if not container_available():
		return False
	else:
		ret,out = execute('docker logs {} --since 2m'.format(get_container_name()),stderr=subprocess.STDOUT)
		if ret == 0:
			return out
		else:
			return None
def print_logs():
	print(get_logs())

def check_logs():
	logging.debug("Checking container logs")
	output = get_logs()
	if not output or "cannot connect to X server" in output:
		logging.critical("Execution Failed")
		remove_container()
	else:
		logging.info("Execution Succeded")
	logging.debug("End check logs")

def get_threads_size():
	global THREAD_POOL
	return len([t for t in THREAD_POOL if t is not None])

def get_threads_pool_position():
	global THREAD_POOL, MAX_THREAD_POOL
	for i in [ x for x in range(0,MAX_THREAD_POOL) if THREAD_POOL[x] is None ]:
		return i
	return None
	
def get_thread_object(fn):
	pass
	
def join_all_threads():
	global THREAD_POOL, MAX_THREAD_POOL
	max_iter = 8
	init_sleep = 1
	while get_threads_size() > 0 and max_iter > 0:
		max_iter = max_iter - 1
		for i in range(0,MAX_THREAD_POOL):
			if THREAD_POOL[i] is not None and THREAD_POOL[i].is_alive() != True:
				THREAD_POOL[i] = None
		for i in [ x for x in range(0,MAX_THREAD_POOL) if THREAD_POOL[x] is not None ]:
			THREAD_POOL[i].join(1)
		time.sleep(init_sleep)
		#init_sleep = init_sleep + 1
	if max_iter == 0:
		logging.error('Max loop wait while joining threads')
	return True

def create_timer(fn,timer):
	global THREAD_POOL, MAX_THREAD_POOL
	
	timer = float(timer)
	
	if get_threads_size() > MAX_THREAD_POOL:
		logging.warning('Max threads reached, unable to allocate in pool')
		return None
	
	t = get_threads_pool_position()
	namethread = '_timer_{}'.format(fn.__name__)
	logging.debug("Creating timer on {} with name {}".format(t,namethread))
	if t is not None:
		THREAD_POOL[t] = threading.Timer(timer,fn)
		THREAD_POOL[t].setName(namethread)
		THREAD_POOL[t].start()
		return t
	return None

def get_x_permission():
	global current_username
	n = 2
	while n > 0:
		ret, out = execute('xhost')
		if 'access control disabled' in out.lower():
			return True
		else:
			execute('xhost +',False)
		n=n-1
	if n==0:
		logging.error('Max loop wait while getting x permission')
	return False
			
def remove_x_permission():
	n = 2
	while n > 0:
		ret, out = execute('xhost')
		if 'access control enabled' in out.lower():
			return True
		else:
			execute('xhost -',False)
		n=n-1
	if n==0:
		logging.error('Max loop wait while removing x permission')
	return False		

def nwfermi_available():
	ret,lmodules = execute('lsmod')
	lmodules = lmodules.strip().split('\n')
	lmodules = [ m.split()[0] for m in lmodules ]
	if 'nw_fermi' in lmodules:
		logging.info('nw_fermi loaded')
		return True
	else:
		logging.warning('nw_fermi not loaded')
		return False

def check_nwfermi():
	if not nwfermi_available():
		if not load_nwfermi():
			logging.error('Unable to load nw_fermi module, maybe is not installed?')
	if nwfermi_available():
		start_namedev = 'nwfermi'
		nwfermi_devs = [d for x in os.listdir('/dev') if x[:len(start_namedev)] == start_namedev ]
		if (len(nwfermi_devs) > 0):
			return True
		else:
			logging.warning('Board not detected, maybe is not connected?')

def load_nwfermi():
	ret, out = execute('modprobe nw_fermi')
	if ret != 0:
		logging.error("Can't load nw_fermi module, error is: {}".format(out.strip()))
		return False
	return True
	
def get_storage_path():
	global MAIN_STORAGE_NAME
	homedir = pwd.getpwuid(os.geteuid()).pw_dir
	return '{}/{}'.format(homedir,MAIN_STORAGE_NAME)

def get_config_storage_path():
	global CONFIG_STORAGE_NAME
	configdir = '/etc'
	return '{}/{}'.format(configdir,CONFIG_STORAGE_NAME)
	
def permission_storage():
	return os.R_OK|os.W_OK|os.X_OK

def permission_config():
	return os.R_OK|os.X_OK

def storage_available():
	folder = get_storage_path()
	return os.path.exists(folder) and os.access(folder,permission_storage())

def config_storage_available():
	folder = get_config_storage_path()
	return os.path.exists(folder) and os.access(folder,permission_config())
	
def set_permission_dir(folder):
	os.chmod(folder,0o0755)
	return True

def set_permission_configdir(folder):
	ret,out = execute('pkexec chmod 0755 {}'.format(folder))
	if ret == 0:
		return True
	else:
		raise Exception('Error executing chmod, error is: {}'.format(out))

def make_storage():
	folder = get_storage_path()
	if not os.path.exists(folder):
		try:
			os.mkdir(folder)
		except Exception as e:
			logging.warning('Error creating storage path, {}'.format(e))
	if not os.access(folder,permission_storage()):
		try:
			set_permission_dir(folder)
		except Exception as e:
			logging.warning('Error setting permissions on storage path, {}'.format(e))
	return os.path.exists(folder) and os.access(folder,permission_storage())

def make_config_storage():
	folder = get_config_storage_path()
	if not os.path.exists(folder):
		try:
			os.mkdir(folder)
		except Exception as e:
			try:
				ret,out = execute('pkexec mkdir -p {}'.format(folder),stdout=subprocess.STDOUT)
				if ret != 0:
					raise Exception('Unable to create config storage, {}'.format(out))
			except Exception as e2:
				logging.warning('Error creating storage config path, {}'.format(e2))
	if not os.access(folder,permission_config()):
		try:
			set_permission_configdir(folder)
		except Exception as e:
			logging.warning('Error setting permissions on storage config path, {}'.format(e))
	return os.path.exists(folder) and os.access(folder,permission_config())

def get_temp_dir_name():
	return '/tmp/docker_tmp_{}'.format(get_container_name())
	
def make_temp_dir():
	dirname = get_temp_dir_name()
	if not os.path.exists(dirname):
		os.mkdir(dirname())

def start_software():
	try:
		if not get_x_permission():
			logging.critical("Can't get X permission, aborting")
			return False
		check_nwfermi()
		if not storage_available():
			logging.warning("Storage not available, trying to create")
			if make_storage():
				logging.info("New storage created")
			else:
				logging.error("Unable to create storage")
				return False
		if not config_storage_available():
			logging.warning("Config storage not available, trying to create")
			if make_config_storage():
				logging.info("New config storage created")
			else:
				logging.error("Unable to create config storage")
				return False
		if container_running():
			logging.info('Container running, start not needed')
		else:
			if create_timer(check_logs,10) is None:
				logging.warning("Couldn't create log watchdog timer")
				
			if container_available():
				run_container()
			else:
				if not image_available():
					get_image()
				get_container()
		return True
		
	except Exception as e:
		import traceback
		logging.debug(traceback.format_exc())
		logging.debug("Starting software failed, error is: '{}'".format(e))
		return False

def stop_software():
	try:
		if not container_running():
			logging.info('Container not running, stop not needed')
			return True
		else:
			if stop_container():
				logging.info('Container stopped')
			else:
				logging.error('Error when trying to stop running container')
	except Exception as e:
		import traceback
		logging.debug(traceback.format_exc())
		logging.debug("Stopping software failed, error is: '{}'".format(e))
		return False

if __name__ == '__main__':
	logging.info("Running as {} ({})".format(current_username,current_uid))
	parser = argparse.ArgumentParser(description="Lliurex-smart command line tool")
	opts = parser.add_mutually_exclusive_group(required=True)
	opts.add_argument('-start',action='store_true',help="Start software")
	opts.add_argument('-stop',action='store_true',help="Stop software")
	opts.add_argument('-download',action="store_true",help="Download software image")
	opts.add_argument('-clean',action='store_true',help="Clean user installation instance")
	opts.add_argument('-purge',action="store_true",help="Really clean installation")
	opts.add_argument('-clearconfig',action="store_true",help="Clean configuration")
	args=parser.parse_args()
	if args.start:
		result = start_software()
		join_all_threads()
	if args.stop:
		result = stop_software()
	
	logging.info('Exitting')
	