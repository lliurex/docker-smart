#!/usr/bin/env python3

import os
import sys
import subprocess
import logging
import argparse
import time
import threading

IMAGE_NAME='lliurex/lliurex-smart:latest'
CONTAINER_NAME='test-smart'

DEBUG=True
if (DEBUG):
	logging.basicConfig(level=logging.DEBUG)
else:
	logging.basicConfig(level=logging.INFO)


MAX_THREAD_POOL=2
THREAD_POOL=[None]*MAX_THREAD_POOL
DOCKER_IS_INSTALLED=False

import json
def print_dic(obj):
	return json.dumps(obj,indent=4,sort_keys=True)

def execute(cmd,stdout=True,shell=False,stderr=subprocess.DEVNULL,universal_newlines=True):
	command=list()
	if isinstance(cmd,str):
		command.extend(cmd.split())
	elif isinstance(cmd,list):
		command.extend(cmd)
	else:
		raise ValueError("Wrong parameter passed to execute method, error is: '{}'".format(cmd))
	try:
		custom_env = os.environ.copy()
		custom_env["LANG"] = "en"
		custom_env["LANGUAGE"] = "en"
		custom_env["LC_ALL"] = "en.UTF-8"
		#logging.debug(print_dic(custom_env))
		if 'docker' in command[0]:
			command.insert(0,'pkexec')			
		logging.debug("Executing {}".format(command))
		output = subprocess.check_output(command,shell=shell,stderr=stderr,universal_newlines=universal_newlines,env=custom_env)
		retcode = 0
	except subprocess.CalledProcessError as e:
		retcode = getattr(e,"returncode",None)
		output = getattr(e,"output",None)
	except Exception as e:
		retcode = None
		output = None
		raise RuntimeError("Error calling subprocess, error is: '{}'".format(e))
	logging.debug("Command return: '{}' with output '{}'".format(retcode,output.strip()))
	if stdout:
		if output:
			output = output.strip()
		return (retcode, output)
	else:
		if retcode == 0:
			return True
		else:
			return False

def docker_installed():
	global DOCKER_IS_INSTALLED
	
	installed = False
	if not DOCKER_IS_INSTALLED:
		installed = execute('docker -v',False)
	else:
		installed = True

	if installed:
		DOCKER_IS_INSTALLED=True
	else:
		DOCKER_IS_INSTALLED=False
	
	#logging.debug("DOCKER_IS_INSTALLED={}".format(DOCKER_IS_INSTALLED))
	return DOCKER_IS_INSTALLED

def image_available():
	global IMAGE_NAME

	if not docker_installed():
		return False
	ret,out = execute('docker images -a -q ' + IMAGE_NAME)
	if out and len(out) == 12:
		logging.info('Image available')
		return True
	else:
		logging.info('Image not available')
		return False

def remove_image():
	global IMAGE_NAME

	if not docker_installed():
		raise OSError("Docker is not installed")
	ret = execute('docker rmi ' + IMAGE_NAME, False)
	if not image_available():
		return True
	else:
		raise SystemError("Error removing image")

def get_image():
	global IMAGE_NAME

	if not docker_installed():
		raise OSError("docker is not installed")
	return execute('docker pull ' + IMAGE_NAME, False)

def container_available():
	global IMAGE_NAME, CONTAINER_NAME

	if not docker_installed():
		return False
	ret,out = execute('docker ps -a -q  -f=name=' + CONTAINER_NAME + ' -f=ancestor=' + IMAGE_NAME)
	if out and len(out) == 12:
		logging.info('Container is available')
		return True
	else:
		logging.info('Container is not available')
		return False

def get_container():
	global IMAGE_NAME, CONTAINER_NAME

	if not docker_installed():
		raise OSError("Docker is not installed")
	
	cmdline=['docker run']
	cmdline.append('-d')
	cmdline.append('--privileged')
	cmdline.append('-v /tmp/.X11-unix:/tmp/.X11-unix')
	cmdline.append('-e DISPLAY=:0')
	cmdline.append('--name ' + CONTAINER_NAME)
	
	cmdline = ' '.join(cmdline)
	cmdline += ' ' + IMAGE_NAME
	ret = execute(cmdline,False)
	return ret

def run_container():
	global CONTAINER_NAME

	if not docker_installed():
		raise OSError("Docker is not installed")
	ret = execute('docker start ' +  CONTAINER_NAME, shell=False)
	return ret
	
def container_running():
	global CONTAINER_NAME

	if not docker_installed():
		raise OSError("Docker is not installed")
	if not container_available():
		return False
	ret, out = execute('docker ps -a -f=name='+CONTAINER_NAME+' --format {{.Status}}')
	wrong_status = ['dead','removing','exited']
	if out:
		status = out.split()[0] or None
		if not status:
			raise SystemError("Error checking container_running")
		status = status.lower()
		if status in wrong_status:
			return False
		else:
			return True
	
def remove_container():
	global CONTAINER_NAME

	if not docker_installed():
		raise OSError("Docker is not installed")
	if container_available():
		if container_running():
			stop_container()
		ret, out = execute('docker rm '+CONTAINER_NAME)
		if ret == 0:
			return True
		else:
			return False
	return True

def stop_container():
	global CONTAINER_NAME

	if not docker_installed():
		raise OSError("Docker is not installed")
	if container_running():
		stop_container()
	ret, out = execute('docker stop '+CONTAINER_NAME)
	if ret == 0:
		return True
	else:
		return False

def get_logs():
	global CONTAINER_NAME
	
	if not docker_installed():
		raise OSError("Docker is not installed")
	if not container_available():
		return False
	else:
		ret,out = execute('docker logs {} --since 2m'.format(CONTAINER_NAME),stderr=subprocess.STDOUT)
		if ret == 0:
			return out
def print_logs():
	pass
	#print(get_logs())

def check_logs():
	output = get_logs()
	if not output or "cannot connect to X server" in output:
		logging.critical("Execution Failed")
		remove_container()
	else:
		logging.info("Execution Succeded")

def get_threads_size():
	global THREAD_POOL
	return len([t for t in THREAD_POOL if t is not None])

def get_threads_pool_position():
	global THREAD_POOL, MAX_THREAD_POOL
	for i in [ x for x in range(0,MAX_THREAD_POOL) if THREAD_POOL[x] is None ]:
		return i
	return None
	
def get_thread_object(fn):
	pass
	
def join_all_threads():
	global THREAD_POOL, MAX_THREAD_POOL
	max_iter = 10
	while get_threads_size() > 0 and max_iter > 0:
		max_iter = max_iter - 1
		for i in range(0,MAX_THREAD_POOL):
			if THREAD_POOL[i] is not None and THREAD_POOL[i].is_alive() != True:
				THREAD_POOL[i] = None
		for i in [ x for x in range(0,MAX_THREAD_POOL) if THREAD_POOL[x] is not None ]:
			THREAD_POOL[i].join(1)
	return True

def create_timer(fn,timer):
	global THREAD_POOL, MAX_THREAD_POOL
	
	timer = float(timer)
	
	if get_threads_size() > MAX_THREAD_POOL:
		logging.warning('Max threads reached, unable to allocate in pool')
		return None
	
	t = get_threads_pool_position()
	logging.debug("Creating timer on {}".format(t))
	if t is not None:
		THREAD_POOL[t] = threading.Timer(timer,fn)
		THREAD_POOL[t].start()
		return t
	return None

def start_software():
	try:
		if not get_x_permission():
			logging.critical("Can't get X permission, aborting")
			return False
		if not container_running():
			if container_available():
				run_container()
			else:
				if not image_available():
					get_image()
				get_container()
		
			if create_timer(check_logs,3) is None:
				logging.warning("Couldn't create log watch timer")
		return True
		
	except Exception as e:
		import traceback
		logging.debug(traceback.format_exc())
		logging.debug("Starting software failed, error is: '{}'".format(e))
		return False

def get_x_permission():
	n = 2
	while n > 0:
		ret, out = execute('xhost')
		if 'access control disabled' in out.lower():
			return True
		else:
			execute('xhost +',False)
			n=n-1
	return False
			
def remove_x_permission():
	n = 2
	while n > 0:
		ret, out = execute('xhost')
		if 'access control enabled' not in out.lower():
			return True
		else:
			execute('xhost -',False)
			n=n-1
	return False		
		

if __name__ == '__main__':
	result = start_software()
	join_all_threads()
	print('Exitting')
	