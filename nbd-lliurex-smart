#!/bin/bash

## START EDITABLE VARS
DOWNLOAD_HOST=http://lliurex.net
DNSNAME_IMG_HOST=server
DOWNLOAD_PATH=recursos
DOWNLOAD_FILENAME=fs-smart
REGISTERED_IMAGE_NAME=lliurex-smart-nbd
BLK_DIR=/opt/ltsp/blockdev
IMG_FILENAME=nbd-fs-smart.img
IMAGE_EXT=xz
CRC_EXT=md5
FIXED_NBD_DEVICE=9

## END EDITABLE VARS

HTTP_FILENAME="${DOWNLOAD_HOST}/${DOWNLOAD_PATH}/${DOWNLOAD_FILENAME}.${IMAGE_EXT}"
HTTP_FILENAME_CRC="${DOWNLOAD_HOST}/${DOWNLOAD_PATH}/${DOWNLOAD_FILENAME}.${CRC_EXT}"
TMP_FILENAME="/tmp/${DOWNLOAD_FILENAME}.${IMAGE_EXT}"
TMP_FILE_CRC="/tmp/${DOWNLOAD_FILENAME}.${CRC_EXT}"
NBD_DEVICE="/dev/nbd$FIXED_NBD_DEVICE"

ensure_module_loaded(){
	if [ -z "$(lsmod|sed -nr '/^nbd\s+/p')" ];then
		modprobe nbd
	fi
}
is_linked(){
	2>&1 nbd-client -c $1 > /dev/null
	if [ $? -eq 0 ];then
		return 0
	fi
	return 1
}
echo_nbd_server_conf(){
	echo "[${REGISTERED_IMAGE_NAME}]"
	echo "exportname = ${BLK_DIR}/${IMG_FILENAME}"
	echo "copyonwrite = true"
}
prepare_blkdir(){
	echo "Preparing blockdir...";
	mkdir -p ${BLK_DIR}
	chown root:nbd ${BLK_DIR}
	chmod 1775 ${BLK_DIR}
}
move_image_to_blkdir(){
	echo "Preparing image into right place...";
	if [ ! -d ${BLK_DIR} ]; then
		echo "Directory '${BLK_DIR}' not found"
		exit 1
	fi
	mv ${TMP_FILENAME} ${BLK_DIR}
	xz -d ${BLK_DIR}/${DOWNLOAD_FILENAME}.${IMAGE_EXT}
	mv ${BLK_DIR}/${DOWNLOAD_FILENAME} ${BLK_DIR}/${IMG_FILENAME}
}
download_image(){
	echo "Downloading image.... (Note: you can avoid this process putting correct file into /tmp)";
	if [ ! -f "${TMP_FILE_CRC}" ]; then
		curl --progress-bar -SL -o ${TMP_FILE_CRC} ${HTTP_FILENAME_CRC}
	fi
	if [ ! -f "${TMP_FILENAME}" ]; then
		curl --progress-bar -SL -o ${TMP_FILENAME} ${HTTP_FILENAME}
	fi
		
	md5="$(cat ${TMP_FILE_CRC} | cut -f1 -d\ )"
	filemd5="$(md5sum ${TMP_FILENAME} | cut -f1 -d\ )"
	if [ "x${md5}" != "x${filemd5}" ]; then
		echo "Error image checksum"
		echo -n "Retry download? y/N "
		read resp
		if [ "x$resp" = "xy" -o "x$resp" = "xY" ]; then
			rm -f "${TMP_FILE_CRC}"
			rm -f "${TMP_FILENAME}"
			download_image
		else
			exit 1
		fi
	else
		echo "Checksum OK!"
	fi
}
connect_image(){
	ensure_module_loaded
	echo "Linking image..."
	valid_dev=""
	if check_client_alive; then
		if [ -n "$(get_info_nbd_from_image dev $REGISTERED_IMAGE_NAME)" ]; then
			echo "Image currently connected"
			exit 1
		fi
		for d in /dev/nbd{0..12}; do
			if [ -b ${d} ]; then
				test_dev=$(nbd-client -c ${d})
				if [ "${test_dev}" == "" ];then
					valid_dev=${d}
					break
				fi
			fi
		done
	else
		if is_linked $NBD_DEVICE; then
			echo "Image currently connected"
			exit 1
		else
			valid_dev=$NBD_DEVICE
		fi	
	fi
	if [ -n "${valid_dev}" ]; then
		nbd-client ${DNSNAME_IMG_HOST} -name ${REGISTERED_IMAGE_NAME} ${valid_dev} -p
	fi
	if [ -z "$(nbd-client -c ${valid_dev})" ]; then
		echo "Error connecting image"
		exit 1
	fi
}
check_client_alive(){
	if [ -n "$(lsof 2>/dev/null|grep nbd-client)" ];then
		return 0
	fi
	return 1
}
get_info_nbd_from_image(){
	query=$1
	filter=$2
	if check_client_alive; then
		for pid in $(lsof 2>/dev/null|grep nbd-client|sed -r 's/\s+/\t/g'|cut -f2|sort|uniq); do
			cmdline="$(cat /proc/$pid/cmdline|xargs -0)"
			fullinfo="$(echo $pid $cmdline|sed -r 's/\s+/\t/g')"
			nfields=$(echo $fullinfo|wc -w)
			if [ -n "$filter" ]; then
				if [ -z "$(echo $fullinfo|grep $filter)" ];then
					continue
				fi
			fi
			imgname=""
			dev=""
			for num in $(seq 3 $nfields); do
				field=$(echo $fullinfo|sed -r 's/\s+/\t/g'|cut -f$num)
				if [ "$field" = "-N" -o "$field" = "-name" ];then
					nadd=$(($num+1))
					imgname="$(echo $fullinfo|sed -r 's/\s+/\t/g'|cut -f$nadd)"
				fi
				if [ "/dev/nbd" = "$(echo $field|cut -c -8)" ];then
					dev=$field
				fi
			done
			case $query in
				pid)
					ret="$pid"
				;;
				server)
					ret="$(echo $fullinfo|cut -f3)"
				;;
				name)
					ret="$imgname"
				;;
				dev)
					ret="$dev"
				;;
				*)
				;;
			esac
			if [ -n "$ret" ]; then
				echo $ret
			fi
		done
	else
		case $query in
			pid)
				echo "Not available on this system"
			;;
			server)
				echo "Not available on this system"
			;;
			name)
				echo "Not available on this system"
			;;
			dev)
				echo "$NBD_DEVICE"
			;;
			*)
				echo "$NBD_DEVICE"
			;;
		esac
	fi
}
disconnect_image(){
	echo "Unlinking image...";
	dev="$(get_info_nbd_from_image dev $REGISTERED_IMAGE_NAME)"
	if [ -z "$dev" ];then
		echo "Image not connected"
		exit 1
	fi
	nbd-client -d $dev
}
mount_image(){
	echo "Mounting image into filesystem...";
	dev="$(get_info_nbd_from_image dev $REGISTERED_IMAGE_NAME)"
	if [ -z "$dev" ]; then
		echo "Image not connected, unable to mount"
		exit 1
	fi
	mkdir -p /var/lib/docker
	dev="$(echo $dev|sed -r 's/\s+/\t/g'|cut -f1)"
	if [ -z "$(findmnt -nr|sed -nr '/^\/var\/lib\/docker\s+/p')" ]; then
		mount $dev /var/lib/docker
	else
		echo "Path is already mounted"
		exit 1
	fi
}
umount_image(){
	echo "Unmounting image from filesystem...";
	if [ -n "$(findmnt -nr|sed -nr '/^\/var\/lib\/docker\s+/p')" ]; then
		kill_docker_daemon
		umount -l $dev /var/lib/docker
	else
		echo "Path is not mounted"
		exit 1
	fi
}
kill_docker_daemon(){
	echo "Stopping docker daemon...";
	systemctl stop docker
	p="$(pidof dockerd)"
	if [ -n "$p" ]; then
		kill -9 $p
	fi
}
start_docker_daemon(){
	echo "Starting docker daemon...";
	systemctl start docker
	p="$(pidof dockerd)"
	if [ -z "$p" ]; then
		systemctl start docker
		p="$(pifof dockerd)"
		if [ -z "$p" ]; then
			echo "Unable to start dockerd through systemd, try to exec dockerd as root and see logs"
			exit 1
		fi
	fi
}
restart_nbd_server(){
	echo "Restarting nbd server...";
	systemctl restart nbd-server
}

help(){
	echo -e '\n Available options (recommended usage):\n ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n "install-server" : Configures a server to allow semi-light clients run smart software\n "run-semi" : Start service into semi-light environment\n "end-semi" : Stop service into semi-light environment\n\n Available options (advanced or manual usage):\n ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n "mount" : mount docker runtime dir\n "umount" : unmount docker runtime dir\n "download" : download docker runtime filesystem image\n "connect" : connect nbd client to server\n "disconnect" : disconnect nbd client from server\n "start" : starts docker daemon\n "stop" : stops docker daemon\n "prepare" : Setups blockdir to store filesystem image into server\n "move" : move downloaded image into blockdir\n "info" : get info querying nbd-client [pid|server|name|dev] [STRING_FILTER]\n "echo-server-conf" : prints nbd server configuration\n'
}

if [ $# -eq 0 ]; then
	echo "Need operational parameters"
	help
	exit 1
fi

need_root(){
    if [ $UID != 0 ]; then
	    echo "Need root permission"
	    exit 1
    fi
}   

# TODO: CHECK SEMI OR ABORT FOR RUN OPTIONS
# TODO: CHECK SERVER OR ABORT FOR SERVER OPTIONS
while [ -n "$1" ]; do
	operation="$(echo $1 |tr '[:upper:]' '[:lower:]')"
	case $operation in
		mount)
			need_root
			mount_image
		;;
		umount)
			need_root
			umount_image
		;;
		download)
			download_image
		;;
		connect)
			need_root
			connect_image
		;;
		disconnect)
			need_root
			disconnect_image
		;;
		start)
			need_root
			start_docker_daemon
		;;
		stop)
			need_root
			kill_docker_daemon
		;;
		prepare)
			need_root
			prepare_blkdir
		;;
		move)
			need_root
			move_image_to_blkdir
		;;
		info)
			need_root
			get_info_nbd_from_image $2 $3
			shift
			shift
		;;
		install-server)
			need_root
			download_image
			prepare_blkdir
			move_image_to_blkdir
			echo_nbd_server_conf > /etc/nbd-server/conf.d/${REGISTERED_IMAGE_NAME}.conf
			restart_nbd_server
		;;
		run-semi)
			need_root
			connect_image
			mount_image
			#kill_docker_daemon
			#start_docker_daemon
		;;
		end-semi)
			need_root
			kill_docker_daemon
			umount_image
			disconnect_image
		;;
		echo-server-conf)
			echo_nbd_server_conf
		;;
		*)
			echo "Not implemented"
			help
			exit 1
		;;
	esac
	shift
done
exit 0

